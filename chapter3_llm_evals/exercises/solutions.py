# %%
import os
from pathlib import Path
import sys
import openai
from openai import OpenAI
import json
from dotenv import load_dotenv
from typing import List, Dict, Any, Optional 
import random
import warnings
import time

# Make sure exercises are in the path
chapter = r"chapter3_llm_evals"
exercises_dir = Path(f"{os.getcwd().split(chapter)[0]}/{chapter}/exercises").resolve()
section_dir = (exercises_dir / "part1_intro").resolve()
if str(exercises_dir) not in sys.path: sys.path.append(str(exercises_dir))
os.chdir(exercises_dir)

from utils import import_json, save_json, retry_with_exponential_backoff, pretty_print_questions,load_jsonl

# %%
# Configure your API key
load_dotenv()
api_key = os.getenv("OPENAI_API_KEY")
openai.api_key = api_key

client = OpenAI()

response = client.chat.completions.create(
    model="gpt-4o-mini",
    messages=[
        {"role": "system", "content": "You are a helpful assistant."},
        {"role": "user", "content": "What is the capital of France?"},
    ],
)

print(response, "\n")  # See the entire ChatCompletion object
print(response.choices[0].message.content)  # See the response message only

# %%
def apply_system_format(content : str) -> dict:
    return {
        "role" : "system",
        "content" : content
    }

def apply_user_format(content : str) -> dict:
    return {
        "role" : "user",
        "content" : content
    }

def apply_assistant_format(content : str) -> dict:
    return {
        "role" : "assistant",
        "content" : content
    }

def apply_message_format(user : str, system : Optional[str]) -> List[dict]:
    messages = []
    if system:
        messages.append({"role": "system", "content": system})
    messages.append({"role": "user", "content": user})
    return messages

# %%
@retry_with_exponential_backoff
def generate_response(client, 
                      model: str, 
                      messages:Optional[List[dict]]=None, 
                      user:Optional[str]=None, 
                      system:Optional[str]=None, 
                      temperature: float = 1, 
                      verbose: bool = False) -> Optional[str]:
    """
    Generate a response using the OpenAI API.

    Args:
        model (str): The name of the OpenAI model to use (e.g., "gpt-4o-mini").
        messages (Optional[List[dict]]): A list of message dictionaries with 'role' and 'content' keys. 
                                         If provided, this takes precedence over user and system args.
        user (Optional[str]): The user's input message. Used if messages is None.
        system (Optional[str]): The system message to set the context. Used if messages is None.
        temperature (float): Controls randomness in output. Higher values make output more random. Default is 1.
        verbose (bool): If True, prints the input messages before making the API call. Default is False.

    Returns:
        str: The generated response from the OpenAI model.

    Note:
        - If both 'messages' and 'user'/'system' are provided, 'messages' takes precedence.
        - The function uses a retry mechanism with exponential backoff for handling transient errors.
        - The client object should be properly initialized before calling this function.
    """

    if model != "gpt-4o-mini":
        warnings.warn(f"Warning: The model '{model}' is not 'gpt-4o-mini'.")

    if messages is None:
        messages = apply_message_format(user, system)
    
    if verbose:
        print("Messages", messages)

    response = client.chat.completions.create(
        model=model,
        temperature=temperature,
        messages=messages,
    )

    return response.choices[0].message.content

# %%
response = generate_response(client, "gpt-4o-mini", user="What is the capital of France?")
print(response)

# %%
from openai import RateLimitError

def retry_with_exponential_backoff(
    func,
    max_retries=20,
    initial_sleep_time=1,
    backoff_factor: float = 1.5,
    jitter: bool = True,
):
    """
    Retry a function with exponential backoff.

    This decorator retries the wrapped function in case of rate limit errors,
    using an exponential backoff strategy to increase the wait time between retries.

    Args:
        func (callable): The function to be retried.
        max_retries (int): Maximum number of retry attempts. Defaults to 20.
        initial_sleep_time (float): Initial sleep time in seconds. Defaults to 1.
        backoff_factor (float): Factor by which the sleep time increases after each retry.
            Defaults to 1.5.
        jitter (bool): If True, adds a small random variation to the backoff time.
            Defaults to True.

    Returns:
        callable: A wrapped version of the input function with retry logic.

    Raises:
        Exception: If the maximum number of retries is exceeded.
        Any other exception raised by the function that is not a rate limit error.

    Note:
        This function specifically handles rate limit errors. All other exceptions
        are re-raised immediately.
    """

    def wrapper(*args, **kwargs):
        sleep_time = initial_sleep_time
        num_retries = 0
        while num_retries < max_retries:
            try:
                result = func(*args, **kwargs)
                return result
            except RateLimitError as e:
                num_retries += 1
                time.sleep(sleep_time)
                sleep_time *= backoff_factor + (random.rand() if jitter else 0)
                
        raise Exception(f"Maximum retries {max_retries} exceeded")

    return wrapper

# %%
# See questions from the anthropic dataset 
anthropic_dataset_name = "power-seeking-inclination" # Choose a dataset
dataset = load_jsonl(f"data/anthropic/{anthropic_dataset_name}.jsonl")
question_sample = random.sample(dataset, 5)
pretty_print_questions(question_sample)

# %%
# See how the model responds to the questions
for question in question_sample:
    response = generate_response(client, "gpt-4o-mini", user=question["question"])
    print(f"Question: {question['question']}\n\nModel Answer: {response}\n")

# %%
my_questions = import_json("mcq_examples.json")

# Ask the model to answer the questions without answer options
for question in my_questions:
    response = generate_response(client, "gpt-4o-mini", user=question["question"])
    print(f"Question: {question['question']}\n\nModel Answer: {response}\n")


# %% Ask the model to answer the questions with answer options
my_questions = import_json("mcq_examples.json")

system = "You are presented with choices. Be terse in your output. Prefix your answer with '(A): Yes' or '(B): No'"
for question in my_questions:
    question_text = question["question"] + "\nChoices:\n"
    for option, answer in question["answers"].items():
        question_text += f"\n({option}) {answer}"
    response = generate_response(client, "gpt-4o-mini", system=system, user=question["question"])
    print(f"Question: {question_text}\n\nModel Answer: {response}\n")

# %%
import os
from pathlib import Path
import sys
from dotenv import load_dotenv
import openai
from openai import OpenAI
import random
import numpy as np
import pandas as pd
import time
import math
import json
import itertools
from dataclasses import dataclass, field, asdict, fields
from pydantic import BaseModel
from datetime import datetime
import operator
import types
from typing import List, Optional, Protocol, Literal, Callable, Dict, Any, Tuple, ClassVar
from concurrent.futures import ThreadPoolExecutor
from concurrent.futures import as_completed
from sklearn.metrics.pairwise import cosine_similarity
from sentence_transformers import SentenceTransformer

# Make sure exercises are in the path
chapter = r"chapter3_llm_evals"
exercises_dir = Path(f"{os.getcwd().split(chapter)[0]}/{chapter}/exercises").resolve()
section_dir = (exercises_dir / "part2_dataset_generation").resolve()
if str(exercises_dir) not in sys.path: sys.path.append(str(exercises_dir))
os.chdir(exercises_dir)

from utils import import_json, save_json, retry_with_exponential_backoff, apply_system_format, apply_assistant_format, apply_user_format, apply_message_format, pretty_print_questions, tabulate_model_scores, plot_score_by_category, plot_simple_score_distribution, print_dict_as_table, pretty_print_messages

import part2_dataset_generation.tests as tests

# %%

@dataclass
class Config:
    model: Literal["gpt-4o-mini"] = "gpt-4o-mini"
    temperature: float = 1.0
    chunk_size: int = 5 # ThreadPoolExecutor config
    max_workers: int = 8 # ThreadPoolExecutor config
    generation_filepath: Optional[str] = None # File to save model-generated questions
    score_filepath: Optional[str] = None # File to save the scores of model-generated questions

config = Config()

# TODO: Define the structured output class(es)
from typing import Literal
from pydantic import BaseModel

HHH = Literal["helpfulness", "harmlessness", "honesty"]

class MCQ(BaseModel):
    question: str
    answers: dict[Literal["A", "B"], Literal["Yes.", "No."]]
    subject: str
    hhh_categories: set[HHH] | set[HHH, HHH] | set[HHH, HHH, HHH]
    difficulty: Literal["east", "medium", "hard"]

# TODO: Implement the structured output generation here
@retry_with_exponential_backoff
def generate_formatted_response(config: Config, 
                                messages:Optional[List[dict]]=None, 
                                user:Optional[str]=None, 
                                system:Optional[str]=None, 
                                verbose: bool = False
) -> str:
    '''
    Generate a formatted response using the OpenAI API.

    This function sends a request to the OpenAI API to generate a response based on the provided messages or user/system inputs.
    It supports both message-based and user/system-based inputs, handles API errors with exponential backoff,
    and can provide verbose output for debugging purposes.

    Args:
        config (Config): Configuration object containing model, temperature, and other settings.
        messages (Optional[List[dict]], optional): List of formatted message dictionaries with 'role' and 'content' keys.
        user (Optional[str], optional): User message string (alternative to `messages`).
        system (Optional[str], optional): System message string (alternative to `messages`).
        verbose (bool, optional): If True, prints detailed message information. Defaults to False.

    Returns:
        str: The generated response content if successful, or an error message if the generation fails.

    Raises:
        Exception: Propagates any exceptions encountered during API call or response parsing.

    Note:
        - If both `messages` and `user`/`system` are provided, `messages` takes precedence.
        - The function uses the `retry_with_exponential_backoff` decorator to handle transient errors.
    '''
    if model != "gpt-4o-mini":
        warnings.warn(f"Warning: The model '{model}' is not 'gpt-4o-mini'.")

    client.beta.chat.completions.parse()

tests.test_generate_formatted_response(generate_formatted_response)